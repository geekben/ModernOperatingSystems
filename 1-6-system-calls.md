##1.6 系统调用
我们知道操作系统的两大功能：提供用户程序的抽象接口和管理计算机的资源。大多数情况下，用户程序和操作系统的交互涉及到前者；比如创建，写入，读出，删除文件。资源管理部分对用户而言是透明的，自动完成的。所以用户程序和操作系统之间的接口就是在做抽象。要真正理解操作系统，我们要仔细的观察这些接口。每个操作系统提供的系统调用都不同（虽然他们的地层概念是相通的）。

我们被迫从两点之间作出选择：（1）笼统的介绍（操作系统都有个read系统调用）（2）针对某个系统详细阐述（UNIX系统有个read系统调用，它又三个参数：一个指定要读的文件，一个指出数据要放的位置，最后一个用来告诉系统要读多少字节）。

我们选择第二种方式，这样工作量更大，但是能更加深入地剖析操作系统的原理。虽然这里专门针对POSIX来讨论，即UNIX，system V，Linux，BSD，MINIX3等等，但是其他现代操作系统也有对应的系统调用来实现同样的功能，至多是细节有所不同。由于实际的系统调用发起过程都是高度依赖硬件实现并用汇编语言来表示的，所以通常会提供函数库让C语言以及其他高级语言方便调用。

记住下面几点很有必要。任何单CPU的计算机一次只能运行一条指令。如果一个进程在用户空间运行并且需要系统为其服务，比如从文件读取一些数据，它就必须执行一条陷入指令，把控制权交给操作系统。操作系统通过检查参数来获悉调用者需要什么样的服务。然后操作系统执行这个系统调用并把控制权交还给系统调用指令的下一条指令。某种意义上来说，系统调用只是一种特殊的函数调用，唯一的区别是系统调用需要进入内核，而函数调用不需要。

为了让系统调用的原理更加清晰，让我们快速的剖析一下read系统调用。如前所述，它有三个参数：第一个参数指定文件，第二个参数指向数据缓冲区，最后一个参数给出要读取的字符数。和其他所有的系统调用一样，他是由C程序调用库函数发起的，这个库函数和系统调用名同名：read。一个C语言的系统调用函数可能是这样的：
count ＝ read(fd, buffer, nbytes);

系统调用（同时也是对应的库函数）返回实际读取的字符数count。这个值通常和nbytes相等，但是也有可能小一点，比如在读取的过程中遇到了文件结束符。

如果系统调用由于非法参数或者磁盘错误而无法执行，那么将返回-1，同时将错误码放入一个全局变量errno中。应用程序应该总是在执行系统调用后检查是否有错误发生。

系统调用是一系列步骤组合完成的。为了让这个概念更清晰，我们回过头来检视前面讨论过的read系统调用。在调用read库函数，进而触发read系统调用之前需要做一些准备工作，调用程序先把参数压到栈里，如图1-17的步骤1-3所示。

C和C++的编译器按倒序将参数压栈，这是有历史原因的（为了使printf函数的第一个参数-格式字符串，出现在栈顶）。第一个和第三个参数是值传递，而第二个参数是引用传递，意味着传递的是buffer的地址（以&符表示取地址），而不是buffer中的内容。然后才是真正对库函数的调用（第四步）。这个调用指令是个通用的函数调用指令，用于调用所有的函数。

库函数通常是由汇编函数写成，他们一般会把系统调用号放到操作系统期望的地方，比如某个寄存器中（第五步）。然后他执行一条TRAP指令，从用户态切换到内核态，然后从一个内核固定地址开始执行（第六步）。TRAP指令和函数调用指令在某种意义上是相似的，他们的下一条执行指令都是从一定距离之外的地址获取的，同时将返回地址保存在栈中稍后使用。

当然，TRAP指令和普通函数调用指令也有两点基本的区别。首先，TRAP指令还有切换运行模式的副作用，而函数调用不会切换模式；其次，TRAP指令不像函数调用指令那样可以跳转到任意地址。取决于架构实现的不同，他或者只能跳转到单一的固定地址，或者采用一个8bit的索引值在一个存在于内存中的表中查找到跳转目的地址，或者其他等价的实现方式，总之是不能任意跳转。

在TRAP指令后执行的内核代码首先检查系统调用号，然后将转到对应的系统调用处理函数中执行，处理函数是用系统调用号作为索引在一个系统调用函数指针表中找到的（第七步）。从这里开始系统调用函数执行他的任务（第八步）。一旦处理函数完成工作，控制权可能将被交还给用户空间的调用者-库函数，他接着执行TRAP指令后的那条用户空间代码（第九步）。这个库函数再通过常规的函数调用返回的方式返回到调用的用户程序中（第十步）。

为了完成这个过程，用户程序要清理栈，和常规的函数调用结束时一样（第十一步）。假设栈是向下增长的，通常这就是实际情况，编译后的代码通过增加栈指针，使其正好回到函数参数压栈之前的位置上，看起来就像什么都没有发生过那样。此时，程序可以随心所欲地去做他接下来想做的任何事情。

在第九步，我们提到控制权可能会交还给库函数是有原因的。系统调用可能会阻塞调用者，使其不能继续运行。比如一个程序要从键盘读入数据，而此时并没有输入，调用者不得不被阻塞。自这种情况下，操作系统会环顾四野找到一个需要执行的程序来填补时间的空白。稍后，如果有输入发生，上述被阻塞的程序会重新得到关注，走完9-11步的流程。

在下面的章节中我们将检视最常用到的POSIX系统调用，或者更具体的，我们将介绍那些发起系统调用的库函数。POSIX有大约100个库函数调用。其中最重要的一些列举在图1-18中，方便起见分为四大类。下面我们将简要的分析每个调用，看看他们都有什么功能。

很大程度上说，这些系统调用就决定了操作系统几乎所有必须承载的功能，因为在个人电脑上资源管理的工作量是很小的（至少跟支持多用户的大型系统相比是这样）。这些功能包括创建和终止进程，创建删除和读写文件，管理路径，输入输出的支持。

值得注意的是，POSIX库函数和系统调用之间并非一一对应关系。POSIX标准规定了一个操作系统所必须提供的一些接口函数，但是并没有指定他们是系统调用，库函数或者是其他什么。如果一个函数接口可以在不使用系统调用（即不需要切换到内核态）的情况下就能实现，那么为了性能更好一般是不会使用系统调用的。然而，大部分POSIX函数接口确实使用系统调用，基本上都是一个函数对应一个系统调用。少数情况下，几个库函数只不过是互为极小差异的变种，那么此时一个系统调用会对应这多个库函数。

###1.6.1 系统调用之进程管理
图1-18第一组系统调用是关于进程管理的。Fork系统调用就是个很好的切入点。Fork是POSIX中定义的唯一的创建进程的方式。这个系统调用会创建一个与发起者进程一样的复制品，包括文件描述符，寄存器，所有的东西都一样。在调用Fork之后，原进程和复制进程（父子进程）将分道扬镳。在Fork的那个时刻，所有的变量都是相同的值，但是因为父进程的数据是拷贝后创建子进程的，所以接下来一个进程中的变量修改就不会影响到另外一方了。（进程的代码部分，是不可修改的，他将在父子进程之间共享。）Fork系统调用将产生一个返回值，在子进程中是0，在父进程中是子进程的PID（Process IDentifier）。通过这个返回值，两个进程可以分辨出来自己究竟是子进程还是父进程。

大部分情况下，在fork之后，子进程将会执行和父进程不同的代码。拿shell来说，它从终端读入一条命令，然后fork出一个子进程，等待它执行完这条命令并将自己终止以后，再去读取下一条命令。要等待子进程执行完毕，父进程要执行一个waitpid系统调用，它专门用来等待子进程（如果存在多个子进程，可以等待任何子进程）退出。waitpid可以等待某个特定的进程也可以等待所有的子进程退出，只要把第一个参数设置为-1即可。当waitpid执行结束，第二个参数statloc指向的地址将被用来存放子进程的退出状态（正常，不正常，还有退出返回值）。另外还有很多选项通过第三个参数给出，比如是否需要在没有已经退出子进程的情况下立即返回。

现在来思考一下fork是怎么被shell使用的。当我们输入一行命令，shell进程fork出一个新的进程。这个子进程必须执行我们输入的命令。他通过调用execve系统调用来执行新的代码，这回导致他的整个核心映像（所有该进程的内存数据）被替换为新的代码文件，那就是由我们输入的命令的第一个参数来指定的。（事实上，真正的系统调用是exec，但是会有一系列的不同名称的库函数以稍许不同的参数来调用他，这里我们把这些库函数都当做系统调用来看待。）图1-19给出了一个高度简化的shell程序，用以阐述fork，waitpid，execve这些系统调用的使用。

最普遍的情况下，execve有三个参数：被执行的文件名，指向参数数组的指针，指向环境变量数组的指针。我们待会儿就来详细阐述他们。不同的库函数，包括execl, execv, execle, execve，提供了不同的参数指定方式。在本书中，我们将使用exec来代表被这些函数调用的系统调用。

我们来思考这一条命令：cp file1 file2; 他用来将文件file1拷贝到file2。在shell完成fork之后，子进程将定位并执行文件cp，同时将源文件和目的文件的名字传给cp。cp的主程序（如同大多数其他C程序那样）包含一个主函数的声明：main(argc, argv, envp)

这里，argc是命令行中包含的所有部分的计数，包括程序文件名本身。上面的例子里，argc为3。

第二个参数argv，是一个指向数组的指针。
