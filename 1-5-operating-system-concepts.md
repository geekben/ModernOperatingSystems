##1.5 操作系统基本概念
大部分操作系统提供了一些基本概念和抽象，比如进程，地址空间，文件等，这些都是理解这些操作系统的核心概念。下面几个小节我们将简要介绍一些基本概念。这本书接下来会回头围绕这些概念详细阐述。为了详解这些概念，我们将不时地从UNIX系统中找些例子。相同的概念同样存在于其他操作系统中，我们将在后面涉及到他们中的一些。

###1.5.1 进程
所有操作系统中的一个关键概念是**进程**。进程就是执行中的程序。和每个进程紧密相连的是其**地址空间**，从0到某个最大值之间的地址列表，进程可以读写这些地址中的内容。地址空间包含了可执行程序，程序的数据和栈。其他和进程联系起来的是一些资源，通常包括寄存器（包含程序计数器和栈指针），打开的文件列表，注册的定时器。一个进程基本上可以理解为一个掌握了运行某个程序所必须的所有信息的容器。

我们会在稍后的第二章详述进程的概念。到目前为止，最简单的获得对进程的感性认识的方法是想象一个多进程的系统。用户可能打开一个视频编辑器程序，让它对一个长达一小时的视频做格式转换（这种工作可能会耗费数个小时），然后自己再去浏览网页。与此同时，一个后台的电子邮件查收进程可能也在周期性的工作。这样我们有了至少三个被激活的进程：视频编辑器，网页浏览器，电邮接收程序。操作系统周期性的决定停止一个程序然后运行另外一个，很可能是因为第一个程序在过去一两秒内消耗了大于他的份额的CPU时间。

当一个程序暂时被暂停执行了，它必须在稍后以暂停时刻完全不变的状态程序运行起来。这意味着在暂停的过程中必须显式地将进程的所有信息保存在某处。比如，该进程可能为同时读取内容而打开了多个文件。和每个文件关联的是一个指向当前读取位置的指针（也就是下一个需要读取的byte或记录的序号）。当这个进程被暂时挂起，那么这些指针必须被保存，这样当他再次运行时read系统调用可以读取到正确的数据。许多操作系统把除了地址空间内容的其他进程相关信息保存在一个操作系统表结构中，称之为**进程表**，它是一个数据结构的数组，每个单元都对应一个现存的进程。

这样，一个进程包含了他的地址空间，通常称为核心镜像（core image，为了纪念从前使用磁核心内存的时代），还包含了进程表的表项，存放了他的寄存器和其他许多在稍后重新运行该程序时需要的东西。

关键的进程管理系统调用是那些用来创建、终止进程的系统调用。想象一个典型的场景，一个命令解释器进程，或称shell进程，从终端读取命令。用户刚好键入了让某个程序进行编译的命令。shell进程必须立即启动一个新的进程来运行编译器。当这个编译器进程执行完成后，他必须自己调用终止程序的系统调用来终结自己。

如果进程可以创建一个或多个新进程（称之为子进程），而这些进程又可以创建新的进程，那么我们得到了一颗进程树，其结构如图1-13。互相合作完成一个任务的相关进程之间通常需要沟通并且同步他们的活动。这种沟通称为进程间通信，将在第二章详细阐述。

其他进程相关系统调用的功能有：申请更多的内存（或者释放未使用的内存），等待子进程结束，以及使用另外的程序替换掉自己的程序。

有时，会有向不在身边的进程发送信息的需求。例如，一个进程通过网络向另外一个计算机上的进程发送消息。为了对抗信息或者应答信息丢失的可能性，发送者需要要求他的操作系统在指定的数秒钟之后给自己发送通知，这样他就可以在没有收到应答的情况下重新发送消息。设置好这些时钟后，程序就可以做其他工作了。

当这一段指定的时间流逝后，操作系统会发出一个报警信号给相应的进程。这个信号将令该进程停止手头的一切工作，将寄存器保存到栈上，然后开始运行特殊的信号处理程序，比如，重传可能丢失的消息。当信号处理程序结束后，进程将回到之前的状态继续执行。信号是软件对硬件中断的模拟，除了时钟超时外还有很多其他会触发信号的条件。很多硬件捕捉的陷入，比如执行了非法指令或者访问无效地址，都会被转换为信号发送给肇事进程。

每个授权的计算机用户都被系统管理员分配了一个UID（User IDentification）。每个进程都有启动他的用户UID信息。子进程继承父进程的UID。用户可以是某个组的成员，每个组有个GID（Group ID）。

有个UID，在UNIX中称为超级用户，windows中称为管理员，他具有特殊的权利，可以无视一切保护规则。在大的装置中，一般只有系统管理员知道超级用户的密码，但是许多普通用户，尤其是学生，会极尽全力的通过寻找系统漏洞而绕过密码成为超级用户。

我们将在第二章学习进程和进程间通信。

###1.5.2 地址空间
每个计算机都有一些主存，用于放置执行的程序。在一个非常精简的操作系统中，任意时刻只有一个程序在内存中存在。要运行第二个程序，必须先把第一个程序移除，然后再把第二个程序放入内存。

更复杂一些的操作系统允许同时有多个程序在内存中。为了让程序之间（以及和操作系统之间）不会互相干扰，需要引入一些保护机制。虽然这种保护机制是在硬件中实现，但是还是需要操作系统来控制的。

上面的观点聚焦在对计算机主内存的管理和保护上。另一方面，同样重要的和内存相关的问题是进程地址空间的管理。通常，每个进程有自己可用的地址集合，一般从0到某个最大值。最简单的情况下，进程地址空间的最大值要小于主内存的大小。于是进程可以填满他的地址空间，主存有足够的空间来满足他的需求。

然而，许多计算机的地址是32或64比特的，地址空间将分别有2^32或2^64byte。一旦进程的地址空间比计算机主存还要大，并且进程还要全部用光这些地址，什么会发生？在前面说的第一种计算机系统中，这种进程就完全走投无路了。现在，我们有虚拟内存的技术，就像前面提到的，操作系统会将地址空间的一部分保存在主存内，另外的放在磁盘上，然后根据需求在他们之间来回的以小块进行往复搬运。实质上，操作系统创建了地址空间的抽象来表示进程可以访问的地址集合。地址空间和机器的物理地址是解耦的，它可能会大于也可能会小于系统物理内存。对地址空间和物理内存的管理构成了操作系统的重要部分，所以第三部分整个一章都将用来讨论这个话题。

###1.5.3 文件
另一个几乎被所有操作系统支持的关键概念是文件系统。如前所述，操作系统的一大功能就是隐藏磁盘和其他IO设备的特殊性，向程序员提供一个优雅干净的设备无关的文件抽象模型。系统调用是必须的，他们要创建，删除，读取和写文件。在文件可以读取之前，必须先在磁盘上找到他并且打开他。读完之后，必须要把它关闭。所以还要提供这些相关的调用。

为了放置文件，大多数的PC操作系统会提供**目录**的概念用来将文件组织在一起。拿一个学生的例子来说，可能会为每一门他选修的课程建一个目录（用来放置这门课需要用到的程序），另外一个目录用来放电子邮件，再一个放他的万维网主页。这就需要有系统调用来创建和删除目录。操作系统同时也提供了将现存的文件放入某个目录，将文件从目录中移除的系统调用。目录中的项目可能是文件也可能是子目录。这个模型同样给出了一个层级结构——文件系统，见图1-14。

进程和文件层级结构都被组织成了树状，但他们的共同点仅限于此。进程层级结构通常不是很深（多于3层已经不多见了），然而文件层级结构通常由4层，5层甚至更多。进程层级结构的生命周期短，基本上至多几分钟，而目录结构可能会存在很多年。他们的不同点还体现在所有关系和保护方法上。一般只有父进程才能控制和访问子进程，但是总有方法能让文件和目录被他的所有者之外的很多人访问。

每个目录中的文件都有其唯一的自上而下的**路径名**，顶端是文件系统的**根目录**。这种绝对路径名是由从根目录开始直到找到该文件所经过的所有目录列表构成的，并且在这些目录名之间使用斜杠分隔。图1-14中，文件CS101的路径为/Faculty/Prof.Brown/Courses/CS101。开头的斜杠表示这是个绝对路径，即从根目录开始。在此说明一下，Windows中（由于历史原因）使用反斜杠（\）而不是斜杠（/）来分隔路径中的目录，所以上面的目录在Windows中是这样的：\Faculty\Prof.Brown\Courses\CS101。这本书中，我们都使用UNIX风格的路径表达方式。

在每个时刻，每个进程都有一个当前工作目录，不以斜杠开头的路径名就在这个目录下进行查找。举例来说，在图1-14中，如果/Faculty/Prof.Brown是当前工作目录，使用路径名Courses/CS101能够得到和前面给出的绝对路径同样的文件。进程可通过发起一个系统调用来指定新的工作目录。

在一个文件可以被读写之前，它必须先被打开，打开的同时会检查权限。如果访问被允许，系统将返回一个较小的整数，称作文件描述符，将用作后面的对文件的操作。如果访问被禁止，那么返回错误码。

另一个UNIX下的重要概念是挂载文件系统。大部分的桌面电脑有一个或多个光驱，可以插入CD-ROM，DVD和蓝光光盘。他们几乎都有USB接口，可以插入U盘（或固态硬盘），还有些计算机有软盘或者外接硬盘。为了提供一个优雅的方式来处理这些可移动的存储设备，UNIX系统允许这些设备上的文件系统被附加到主文件系统树上。考虑一下图1-15的情况，在mount系统调用之前，在硬盘上的根文件系统和CD-ROM上的文件系统是隔离的，他们之间没有联系。

然而，CD-ROM上的文件系统没办法使用，因为没有指定这个文件系统中的文件路径名的方法。UNIX不允许路径名以驱动器名称或序号为前缀；这是操作系统理应极力避免的对设备的依赖性。取代方案是，mount系统调用，它允许程序将CD-ROM中的文件系统附加到跟文件系统的任何位置。在图1-15(b)中，CD-ROM文件系统被挂载到目录b，于是可以访问文件/b/x和/b/y。如果b目录原来就有一些文件，那么在被挂载期间，这些文件将不能被访问到了，因为b目录位置现在是CD-ROM文件系统的根目录。（不能被访问并不是什么严重的事情：文件系统一般都会被挂载到空目录）如果一个系统有多块硬盘，他们可以被挂载到一颗文件系统树上。

另一个UNIX中的重要概念是**特殊文件**。特殊文件的存在是为了让IO设备看上去和文件一样。这样，他们就可以用读写其他文件相同的系统调用来访问了。有两种特殊文件：块设备文件和字符设备文件。块设备文件抽象那些可以随机寻址的块构成的设备，比如硬盘。如果打开一个块设备文件，如果要读取第4块，那么程序可以直接访问设备上的第四个块区域，不用理会这个设备上的文件系统结构。同样的，字符设备文件用来抽象打印机、调制解调器等其他输入输出为字符流的设备。安装传统，特殊文件放在/dev/目录下。比如/dev/lp可能是个打印机（一度被称为线性打印机）。

在这个概览中，我们还要讨论最后一个特性，它与进程和文件同时相关：管道。管道是一种伪文件，它用于将两个进程连接起来，如图1-16所示。如果进程A和B想通过管道交流，他们必须事先创建好管道。当进程A要向进程B传送数据时，他就想管道里面写入，就好些写输出文件那样。进程B可以从管道里读出数据，就像从输入文件读入一样。于是，UNIX的进程间通信看起来就像是普通的文件读写。更强的是，进程无法感知他所写的输出文件是真实文件还是管道，除了使用一个特殊的系统调用。文件系统非常重要，我们将在第四章，第十章，第十一章对其进行深入的讨论。

###1.5.4 输入输出
所有的计算机都有用于获取输入和产生输出的物理设备。说到底，如果用户无法告诉计算机要做什么，也无法从计算机获取结果，那么要计算机干什么？所以存在许许多多的输入输出设备，包括键盘，显示器，打印机等等。管理这些设备是操作系统的工作。

实际中，每个操作系统都有自己的IO子系统专门用于管理IO设备。有些IO软件是与设备无关的，也就是说，他们适用于许多甚至所有的IO设备。其他部分，比如设备驱动，就只能适用于特定的设备了。在第五章我们将探讨IO软件。

###1.5.5 安全
计算机保存了大量的信息，用户往往希望保护这些信息的安全和隐私。这些信息包括邮件，商业计划，税单等等。由操作系统去管理系统的安全性，保证文件只被授权用户访问。

举个简单的例子，初步了解一下安全是如何工作的，这里还是以UNIX为背景。UNIX中的文件都分配了一个9bit的保护码。保护码由三个3bit的域构成，一个对应所有者，一个对应所有者所在组中的其他用户（用户被管理员分成了很多个组），最后一个对应任意用户。每个域的三个bit对应了读权限，写权限和执行权限。这三个bit又被称作rwx位。比如，保护码rwxr-x--x表示所有者可以读写执行该文件，其他组内成员可以读和执行（但不能写），其他所有用户都只有执行权限。对目录来说，x表示查询权限。短横线表示对应权限缺失。

在文件保护之外，还有很多安全问题。保护系统不被不速之客侵入，无论是人类还是非人类（比如病毒）就是其中一项。我们会在第九章探寻各种安全问题。

###1.5.6 Shell
操作系统是实现了系统调用的代码集合。文本编辑器，编译器，汇编器，链接器，工具程序，还有命令解释器，这些都不属于操作系统，尽管他们非常有用。冒着造成一些概念混淆的风险，这一节我们简要的介绍一下UNIX命令解释器，shell。虽然他不是操作系统的一部分，但是他使用了很多操作系统的特性，于是shell就是展示系统调用如何被使用的绝佳实例。他同时也是坐在终端前的用户与操作系统交互的主要媒介，使用图形界面除外。现存很多种shell，包括sh，csh，ksh和bash。他们都支持下文将介绍的功能，他们都是从sh演化而来。

每当用户登录，一个shell程序就被启动了。shell程序使用终端作为其标准输入输出。他们以打印一个提示符作为开始，提示符是一个字符，比如一个美元符号，他哟过来告诉用户shell正在等待接收命令。如果用户这时候输入：
    date
shell将创建一个子进程，然后在子进程中运行date程序。在子进程运行时，shell等待他退出。当子进程结束运行，shell再次打印提示符同时等待读入下一条输入。

用户可以指定标准输出重定向到一个文件，比如，
    date >file
同样的，标准输入也可以被重定向，像这样，
    sort <file1 >file2
这行命令触发了排序程序sort，从file1中获取输入，并将输出结果送至file2.

一个程序的输出可以作为另一个程序的输入，只要通过管道连接他们。
    cat file1 file2 file3 | sort >/dev/lp
上面的命令触发了cat程序，他会连接三个文件，然后将输出送到排序程序最终得到所有行按字母序排列的输出。sort程序的输出被重定向到文件/dev/lp，一般这是个打印机。

如果用户在命令最后放一个与记号&，shell程序就不再等待子进程运行结束了。而是直接打印命令提示符。
    cat file1 file2 file3 | sort >/dev/lp &
这行命令将以后台任务的形式启动sort程序，这样用户就可以在sort运行的同时干其他事情了。shell还有很多其他有趣的特性，限于篇幅就不在此一一赘述了。很多关于UNIX的书籍都花了不小的篇幅来讨论shell（Kernighan and Pike, 1984; Quigley, 2004; Robbins, 2005）。

现今大多数个人电脑都使用GUI。实际上，GUI也是个运行在操作系统之上的程序，和shell一样。在linux系统中，这个事实非常清晰明了，因为用户可以在至少两个GUI之间做出选择：Gnome和KDE，或者一个都不选，而是使用X11的终端窗口。windows下同样可以将标准的桌面GUI（Windows Explorer）替换为其他的程序，只要改一些注册表的值即可，虽然很少有人这么做。

###1.5.7 个体成长重现种族进化史（重演说）
在查尔斯达尔文的物种起源出版后，德国动物学家Ernst Haeckel提出了“个体成长重现种族进化史”观点。他想表达的是，胚胎（个体）的发育过程重现了种族的演化历程。换句话说，在受精之后，一个人类受精卵经历了鱼，猪等等阶段直到长成人类婴儿。现代生物学家把这个理论看作是粗糙的简化，但是它的确有正确的内涵。

我们可以在计算机产业中发现类似的现象。每个新的物种（大型主机，迷你计算机，个人计算机，手持设备，嵌入式系统，智能卡，等等）看起来就像经历了他们祖先的发展历程，包括硬件和软件。无论是计算机行业还是其他科技驱动的领域，我们经常忘记发生了什么。古罗马人没有汽车的原因不是他们喜欢步行，而是他们压根不懂怎么制造汽车。个人电脑的诞生不是因为人们被压抑了几个世纪的对拥有计算机的渴望，而是廉价制造计算机在今日成为了可能。我们经常忘记就了科技对我们的世界观产生的影响，而不时地回顾一下是非常有价值的。

