##1.6 系统调用
我们知道操作系统的两大功能：提供用户程序的抽象接口和管理计算机的资源。大多数情况下，用户程序和操作系统的交互涉及到前者；比如创建，写入，读出，删除文件。资源管理部分对用户而言是透明的，自动完成的。所以用户程序和操作系统之间的接口就是在做抽象。要真正理解操作系统，我们要仔细的观察这些接口。每个操作系统提供的系统调用都不同（虽然他们的地层概念是相通的）。

我们被迫从两点之间作出选择：（1）笼统的介绍（操作系统都有个read系统调用）（2）针对某个系统详细阐述（UNIX系统有个read系统调用，它又三个参数：一个指定要读的文件，一个指出数据要放的位置，最后一个用来告诉系统要读多少字节）。

我们选择第二种方式，这样工作量更大，但是能更加深入地剖析操作系统的原理。虽然这里专门针对POSIX来讨论，即UNIX，system V，Linux，BSD，MINIX3等等，但是其他现代操作系统也有对应的系统调用来实现同样的功能，至多是细节有所不同。由于实际的系统调用发起过程都是高度依赖硬件实现并用汇编语言来表示的，所以通常会提供函数库让C语言以及其他高级语言方便调用。

记住下面几点很有必要。任何单CPU的计算机一次只能运行一条指令。如果一个进程在用户空间运行并且需要系统为其服务，比如从文件读取一些数据，它就必须执行一条陷入指令，把控制权交给操作系统。操作系统通过检查参数来获悉调用者需要什么样的服务。然后操作系统执行这个系统调用并把控制权交还给系统调用指令的下一条指令。某种意义上来说，系统调用只是一种特殊的函数调用，唯一的区别是系统调用需要进入内核，而函数调用不需要。

为了让系统调用的原理更加清晰，让我们快速的剖析一下read系统调用。如前所述，它有三个参数：第一个参数指定文件，第二个参数指向数据缓冲区，最后一个参数给出要读取的字符数。和其他所有的系统调用一样，他是由C程序调用库函数发起的，这个库函数和系统调用名同名：read。一个C语言的系统调用函数可能是这样的：
count ＝ read(fd, buffer, nbytes);

系统调用（同时也是对应的库函数）返回实际读取的字符数count。这个值通常和nbytes相等，但是也有可能小一点，比如在读取的过程中遇到了文件结束符。

如果系统调用由于非法参数或者磁盘错误而无法执行，那么将返回-1，同时将错误码放入一个全局变量errno中。应用程序应该总是在执行系统调用后检查是否有错误发生。

系统调用是一系列步骤组合完成的。为了让这个概念更清晰，我们回过头来检视前面讨论过的read系统调用。在调用read库函数，进而触发read系统调用之前需要做一些准备工作，调用程序先把参数压到栈里，如图1-17的步骤1-3所示。

C和C++的编译器按倒序将参数压栈，这是有历史原因的（为了使printf函数的第一个参数-格式字符串，出现在栈顶）。第一个和第三个参数是值传递，而第二个参数是引用传递，意味着传递的是buffer的地址（以&符表示取地址），而不是buffer中的内容。然后才是真正对库函数的调用（第四步）。这个调用指令是个通用的函数调用指令，用于调用所有的函数。

库函数通常是由汇编函数写成，他们一般会把系统调用号放到操作系统期望的地方，比如某个寄存器中（第五步）。然后他执行一条TRAP指令，从用户态切换到内核态，然后从一个内核固定地址开始执行（第六步）。TRAP指令和函数调用指令在某种意义上是相似的，他们的下一条执行指令都是从一定距离之外的地址获取的，同时将返回地址保存在栈中稍后使用。

当然，TRAP指令和普通函数调用指令也有两点基本的区别。首先，TRAP指令还有切换运行模式的副作用，而函数调用不会切换模式；其次，TRAP指令不像函数调用指令那样可以跳转到任意地址。取决于架构实现的不同，他或者只能跳转到单一的固定地址，或者采用一个8bit的索引值在一个存在于内存中的表中查找到跳转目的地址，或者其他等价的实现方式，总之是不能任意跳转。

在TRAP指令后执行的内核代码首先检查系统调用号，然后将转到对应的系统调用处理函数中执行，处理函数是用系统调用号作为索引在一个系统调用函数指针表中找到的（第七步）。从这里开始系统调用函数执行他的任务（第八步）。一旦处理函数完成工作，控制权可能将被交还给用户空间的调用者-库函数，他接着执行TRAP指令后的那条用户空间代码（第九步）。这个库函数再通过常规的函数调用返回的方式返回到调用的用户程序中（第十步）。

为了完成这个过程，用户程序要清理栈，和常规的函数调用结束时一样（第十一步）。假设栈是向下增长的，通常这就是实际情况，编译后的代码通过增加栈指针，使其正好回到函数参数压栈之前的位置上，看起来就像什么都没有发生过那样。此时，程序可以随心所欲地去做他接下来想做的任何事情。

在第九步，我们提到控制权可能会交还给库函数是有原因的。系统调用可能会阻塞调用者，使其不能继续运行。比如一个程序要从键盘读入数据，而此时并没有输入，调用者不得不被阻塞。自这种情况下，操作系统会环顾四野找到一个需要执行的程序来填补时间的空白。稍后，如果有输入发生，上述被阻塞的程序会重新得到关注，走完9-11步的流程。
