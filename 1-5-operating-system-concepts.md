##1.5 操作系统基本概念
大部分操作系统提供了一些基本概念和抽象，比如进程，地址空间，文件等，这些都是理解这些操作系统的核心概念。下面几个小节我们将简要介绍一些基本概念。这本书接下来会回头围绕这些概念详细阐述。为了详解这些概念，我们将不时地从UNIX系统中找些例子。相同的概念同样存在于其他操作系统中，我们将在后面涉及到他们中的一些。

###1.5.1 进程
所有操作系统中的一个关键概念是**进程**。进程就是执行中的程序。和每个进程紧密相连的是其**地址空间**，从0到某个最大值之间的地址列表，进程可以读写这些地址中的内容。地址空间包含了可执行程序，程序的数据和栈。其他和进程联系起来的是一些资源，通常包括寄存器（包含程序计数器和栈指针），打开的文件列表，注册的定时器。一个进程基本上可以理解为一个掌握了运行某个程序所必须的所有信息的容器。

我们会在稍后的第二章详述进程的概念。到目前为止，最简单的获得对进程的感性认识的方法是想象一个多进程的系统。用户可能打开一个视频编辑器程序，让它对一个长达一小时的视频做格式转换（这种工作可能会耗费数个小时），然后自己再去浏览网页。与此同时，一个后台的电子邮件查收进程可能也在周期性的工作。这样我们有了至少三个被激活的进程：视频编辑器，网页浏览器，电邮接收程序。操作系统周期性的决定停止一个程序然后运行另外一个，很可能是因为第一个程序在过去一两秒内消耗了大于他的份额的CPU时间。

当一个程序暂时被暂停执行了，它必须在稍后以暂停时刻完全不变的状态程序运行起来。这意味着在暂停的过程中必须显式地将进程的所有信息保存在某处。比如，该进程可能为同时读取内容而打开了多个文件。和每个文件关联的是一个指向当前读取位置的指针（也就是下一个需要读取的byte或记录的序号）。当这个进程被暂时挂起，那么这些指针必须被保存，这样当他再次运行时read系统调用可以读取到正确的数据。许多操作系统把除了地址空间内容的其他进程相关信息保存在一个操作系统表结构中，称之为**进程表**，它是一个数据结构的数组，每个单元都对应一个现存的进程。

这样，一个进程包含了他的地址空间，通常称为核心镜像（core image，为了纪念从前使用磁核心内存的时代），还包含了进程表的表项，存放了他的寄存器和其他许多在稍后重新运行该程序时需要的东西。

关键的进程管理系统调用是那些用来创建、终止进程的系统调用。想象一个典型的场景，一个命令解释器进程，或称shell进程，从终端读取命令。用户刚好键入了让某个程序进行编译的命令。shell进程必须立即启动一个新的进程来运行编译器。当这个编译器进程执行完成后，他必须自己调用终止程序的系统调用来终结自己。

如果进程可以创建一个或多个新进程（称之为子进程），而这些进程又可以创建新的进程，那么我们得到了一颗进程树，其结构如图1-13。互相合作完成一个任务的相关进程之间通常需要沟通并且同步他们的活动。这种沟通称为进程间通信，将在第二章详细阐述。

其他进程相关系统调用的功能有：申请更多的内存（或者释放未使用的内存），等待子进程结束，以及使用另外的程序替换掉自己的程序。

有时，会有向不在身边的进程发送信息的需求。例如，一个进程通过网络向另外一个计算机上的进程发送消息。为了对抗信息或者应答信息丢失的可能性，发送者需要要求他的操作系统在指定的数秒钟之后给自己发送通知，这样他就可以在没有收到应答的情况下重新发送消息。设置好这些时钟后，程序就可以做其他工作了。

当这一段指定的时间流逝后，操作系统会发出一个报警信号给相应的进程。这个信号将令该进程停止手头的一切工作，将寄存器保存到栈上，然后开始运行特殊的信号处理程序，比如，重传可能丢失的消息。当信号处理程序结束后，进程将回到之前的状态继续执行。信号是软件对硬件中断的模拟，除了时钟超时外还有很多其他会触发信号的条件。很多硬件捕捉的陷入，比如执行了非法指令或者访问无效地址，都会被转换为信号发送给肇事进程。

每个授权的计算机用户都被系统管理员分配了一个UID（User IDentification）。每个进程都有启动他的用户UID信息。子进程继承父进程的UID。用户可以是某个组的成员，每个组有个GID（Group ID）。

有个UID，在UNIX中称为超级用户，windows中称为管理员，他具有特殊的权利，可以无视一切保护规则。在大的装置中，一般只有系统管理员知道超级用户的密码，但是许多普通用户，尤其是学生，会极尽全力的通过寻找系统漏洞而绕过密码成为超级用户。

我们将在第二章学习进程和进程间通信。

###1.5.2 地址空间
每个计算机都有一些主存，用于放置执行的程序。在一个非常精简的操作系统中，任意时刻只有一个程序在内存中存在。要运行第二个程序，必须先把第一个程序移除，然后再把第二个程序放入内存。

更复杂一些的操作系统允许同时有多个程序在内存中。为了让程序之间（以及和操作系统之间）不会互相干扰，需要引入一些保护机制。虽然这种保护机制是在硬件中实现，但是还是需要操作系统来控制的。

上面的观点聚焦在对计算机主内存的管理和保护上。另一方面，同样重要的和内存相关的问题是进程地址空间的管理。通常，每个进程有自己可用的地址集合，一般从0到某个最大值。最简单的情况下，进程地址空间的最大值要小于主内存的大小。于是进程可以填满他的地址空间，主存有足够的空间来满足他的需求。

然而，许多计算机的地址是32或64比特的，地址空间将分别有2^32或2^64byte。一旦进程的地址空间比计算机主存还要大，并且进程还要全部用光这些地址，什么会发生？在前面说的第一种计算机系统中，这种进程就完全走投无路了。现在，我们有虚拟内存的技术，就像前面提到的，操作系统会将地址空间的一部分保存在主存内，另外的放在磁盘上，然后根据需求在他们之间来回的以小块进行往复搬运。实质上，操作系统创建了地址空间的抽象来表示进程可以访问的地址集合。地址空间和机器的物理地址是解耦的，它可能会大于也可能会小于系统物理内存。对地址空间和物理内存的管理构成了操作系统的重要部分，所以第三部分整个一章都将用来讨论这个话题。

###1.5.3 文件
另一个几乎被所有操作系统支持的关键概念是文件系统。如前所述，操作系统的一大功能就是隐藏磁盘和其他IO设备的特殊性，向程序员提供一个优雅干净的设备无关的文件抽象模型。系统调用是必须的，他们要创建，删除，读取和写文件。在文件可以读取之前，必须先在磁盘上找到他并且打开他。读完之后，必须要把它关闭。所以还要提供这些相关的调用。

为了放置文件，大多数的PC操作系统会提供**目录**的概念用来将文件组织在一起。拿一个学生的例子来说，可能会为每一门他选修的课程建一个目录（用来放置这门课需要用到的程序），另外一个目录用来放电子邮件，再一个放他的万维网主页。这就需要有系统调用来创建和删除目录。同时也提供了将现存的文件放入某个目录，将文件从目录中移除的系统调用。目录一个用户组读取而不是仅仅他的拥有者。
