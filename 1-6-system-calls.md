##1.6 系统调用
我们知道操作系统的两大功能：提供用户程序的抽象接口和管理计算机的资源。大多数情况下，用户程序和操作系统的交互涉及到前者；比如创建，写入，读出，删除文件。资源管理部分对用户而言是透明的，自动完成的。所以用户程序和操作系统之间的接口就是在做抽象。要真正理解操作系统，我们要仔细的观察这些接口。每个操作系统提供的系统调用都不同（虽然他们的地层概念是相通的）。

我们被迫从两点之间作出选择：（1）笼统的介绍（操作系统都有个read系统调用）（2）针对某个系统详细阐述（UNIX系统有个read系统调用，它又三个参数：一个指定要读的文件，一个指出数据要放的位置，最后一个用来告诉系统要读多少字节）。

我们选择第二种方式，这样工作量更大，但是能更加深入地剖析操作系统的原理。虽然这里专门针对POSIX来讨论，即UNIX，system V，Linux，BSD，MINIX3等等，但是其他现代操作系统也有对应的系统调用来实现同样的功能，至多是细节有所不同。由于实际的系统调用发起过程都是高度依赖硬件实现并用汇编语言来表示的，所以通常会提供函数库让C语言以及其他高级语言方便调用。

记住下面几点很有必要。任何单CPU的计算机一次只能运行一条指令。如果一个进程在用户空间运行并且需要系统为其服务，比如从文件读取一些数据，它就必须执行一条陷入指令，把控制权交给操作系统。操作系统通过检查参数来获悉调用者需要什么样的服务。然后操作系统执行这个系统调用并把控制权交还给系统调用指令的下一条指令。某种意义上来说，系统调用只是一种特殊的函数调用，唯一的区别是系统调用需要进入内核，而函数调用不需要。

为了让系统调用的原理更加清晰，让我们快速的剖析一下read系统调用。如前所述，它有三个参数：第一个参数指定文件，第二个参数指向数据缓冲区，最后一个参数给出要读取的字符数。和其他所有的系统调用一样，他是由C程序调用库函数发起的，这个库函数和系统调用名同名：read。一个C语言的系统调用函数可能是这样的：
count ＝ read(fd, buffer, nbytes);

系统调用（同时也是对应的库函数）返回实际读取的字符数count。这个值通常和nbytes相等，但是也有可能小一点，比如在读取的过程中遇到了文件结束符。

如果系统调用由于非法参数或者磁盘错误而无法执行，那么将返回-1，同时将错误码放入一个全局变量errno中。应用程序应该总是在执行系统调用后检查是否有错误发生。
